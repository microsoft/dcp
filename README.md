# Developer Control Plane

This repository contains the Developer Control Plane tool (or DCP for short). DCP is implemented as a single binary (`dcp`) that can run in one of several modes depending on how it is invoked. The main modes of operation are:
- `dcp start-apiserver` - runs the DCP API server that holds the workload model and exposes a Kubernetes-compatible API for managing workloads using the [Tilt API server library](https://github.com/tilt-dev/tilt-apiserver). The API server is Kubernetes-compatible but using custom resource definitions. This is the main entry point for DCP; users or other tools such as Aspire invoke DCP in this mode to launch the API server and controllers.
- `dcp run-controllers` - runs the core DCP controllers that implement the standard behavior for DCP workload models. This mode is typically invoked as a child process of the API server.
- `dcp monitor-process` - monitors a given process and ensures that it's cleaned up properly when a DCP session ends. This mode is typically invoked as a child process of the controllers.
- `dcp monitor-container` - monitors a given container and ensures that it's cleaned up properly when a DCP session ends. This mode is typically invoked as a child process of the controllers.
- `dcp stop-process-tree` - stops a given process and all its child processes. Attempts to gracefully terminate the process tree first via signals and then forcibly terminates it if the graceful termination does not complete within a timeout.
- `dcp version` - displays version information about the DCP installation.
- `dcp info` - displays information about the current DCP installation and identified container runtime.

### Environment variables affecting DCP behavior

DCP has knowledge of a number of environment variables that can change its behavior; they are used mostly for testing.

| Variable | Description |
| --- | --------- |
| `DCP_EXTENSIONS_PATH` | Points to directory that contains DCP extensions. By default extensions are placed in the `ext` sub-directory of the directory where DCP main executable is located. |
| `DEBUG_SESSION_PORT`, `DEBUG_SESSION_TOKEN`, and `DEBUG_SESSION_SERVER_CERTIFICATE` | These are variables that configure the endpoint for running Executables via a developer IDE/under debugger. For more information see [IDE execution specification](https://github.com/dotnet/aspire/blob/main/docs/specs/IDE-execution.md). |
| `DCP_SESSION_FOLDER` | This variable is used for isolating multiple DCP instances running concurrently on the same machine. If set (to a valid filesystem folder), DCP process(es) will create files related to their execution in this folder: the access configuration file (kubeconfig), captured Executable/Container logs, etc. |
| `DCP_LOG_SOCKET` | If set to a Unix domain socket, DCP will write its execution logs to that socket instead of writing them to standard error stream (`stderr`). This allows programs that launch DCP to capture its output even if DCP is running in `--detach` mode. <br/> The `--detach` mode causes DCP to fork itself and break the parent-child relationship (and lifetime dependency) from the process that launched it, but the side effect of doing so is that the parent process loses ability to monitor DCP standard output and standard error streamd. |
| `DCP_LOG_SESSION_ID` | If set, DCP will prepend this value to all diagnostics log names. If unset, a session ID will be calculated. The value is propagated to all child DCP processes. |
| `DCP_DIAGNOSTICS_LOG_LEVEL` | If set, enabled DCP diagnostic logging. <br/> Can be set to `error`, `info`, or `debug`; for troubleshooting `debug` is recommended, although it results in the most verbose output. |
| `DCP_DIAGNOSTICS_LOG_FOLDER` | If set to a valid filesystem folder, DCP will place the diagnostic logging files there. Otherwise (if enabled) they are written to the default temporary files folder. |
| `DCP_LOG_FILE_NAME_SUFFIX` | Suffix to append to the log file name (defaults to process ID if not set). |
| `DCP_LOGGING_CONTEXT` | If set, the value of this variable will be written to the log file as one of the first log messages (as verbose, "info" type of message). |
| `DCP_PRESERVE_EXECUTABLE_LOGS` | If set (to "true", "yes", or "1"), the logs from Executables will not be deleted when DCP shuts down. This can be useful to capture results of test runs that use DCP as the workload orchestrator. |
| `DCP_RESOURCE_WATCH_TIMEOUT_SECONDS` | A timeout for resource watch requests, in seconds. Watch requests will time out shortly after the specified value, to avoid the "thundering herd" problem. Useful for testing watch retry logic. |
| `DCP_IDE_REQUEST_TIMEOUT_SECONDS`, `DCP_IDE_NOTIFICATION_TIMEOUT_SECONDS`, and  `DCP_IDE_NOTIFICATION_KEEPALIVE_SECONDS`  | Timeouts for, respectively: requests to IDE run session endpoint (defaults to 120 seconds), request to IDE notification WebSocket endpoint (defaults to 20 seconds), and the time to interpret the lack of response to WebSocket ping message on the IDE notification connection is interpreted as connection failue (defaults to 5 seconds). <br/> The IDE notification keepalive value, if present, must be smaller than the IDE notification request timeout value. <br/> A value of zero for IDE notification keepalive turns off the keep-alives (ping-pong messages) for the IDE notification connection. |
| `DCP_INSTANCE_ID_PREFIX` | A prefix for the automatically generated, random DCP instance ID, which is attached to every communication with the IDE when running Executables via IDE. For more information see [IDE execution specification](https://github.com/dotnet/aspire/blob/main/docs/specs/IDE-execution.md). |
| `DCP_MOST_RECENT_PORT_LIFETIME`, `DCP_PORT_AVAILABILITY_CHECK_TIMEOUT`, `DCP_PORT_ALLOCATION_CHECK_TIMEOUT`, `DCP_PORT_ALLOCATIONS_PER_ROUND`, and `DCP_PORT_ALLOCATION_ROUND_DELAY` | These are parameters that govern the algorithm DCP is using to ensure that dynamically allocated ports are unique for the whole machine, even if multiple DCP instances are running. <br/> <br/> `DCP_MOST_RECENT_PORT_LIFETIME` is the time a recently allocated network port is considered unavailable. Used during automatic port allocation. Defaults to 2 minutes. Note that a particular port number will never be re-used if it is being *actively used* by a program running on the machine, even if that port has been auto-allocated earlier than "lifetime" ago. <br/> <br/> `DCP_PORT_AVAILABILITY_CHECK_TIMEOUT` determines how long DCP will try to access the most recently used ports file when checking for port availability. Defaults to 50 milliseconds. <br/> <br/> `DCP_PORT_ALLOCATION_CHECK_TIMEOUT` determines how long DCP will try to ensure that the allocated port is unique for the whole machine (per single port allocation). Defaults to 1 second. <br/> <br/> `DCP_PORT_ALLOCATIONS_PER_ROUND` determines how many port allocation attempts a DCP instance will make while holding a lock on the most recently used ports file. Defaults to 5. <br/> <br/> `DCP_PORT_ALLOCATION_ROUND_DELAY` tells DCP how long to wait (releasing the lock on the MRU ports file) before attempting to allocate a unique port again. Defaults to 100 ms. <br/> <br/> The values of all these environment variables should be the same as Go `time.Duration` literals (except from `DCP_PORT_ALLOCATIONS_PER_ROUND`, which is a positive integer). |
| `DCP_IP_VERSION_PREFERENCE` | Describes which version of the IP protocol will be preferred for communicating with DCP and for allocating service ports. Can be set to `IPv4`, `v4` or `4` (to prefer IP protocol version 4) or `IPv6`, `v6` or `6` (to prefer IP protocol version 6). <br/> <br/> The preference determines which type of available IP addresses will be preferred when resolving `localhost` host name. `localhost` is the default pseudo-address that both Services and DCP itself bind to. The value of `DCP_IP_VERSION_PREFERENCE` environment variable is not used if a Service requests specific address, or if a Service uses an address allocation mode that is different from `localhost`. |
| `DCP_SHUTDOWN_TIMEOUT_SECONDS` | Overrides the default DCP shutdown timeout (120 seconds). DCP will use this timeout to wait for all resources to be cleaned up before shutting down. |
| `DCP_SECURE_TOKEN` | Provides a predetermined bearer token for DCP to use rather than generating a randm one. If this is set, DCP will write a placeholder value to the kubeconfig file. Any client trying to connect will have to know this predetermined token and apply it to their config themselves. |
| `DCP_PERF_TRACE` | If set, instructs DCP to capture a performance trace during startup and/or shutdown. For more information see [performance investigations page](performance-investigations.md). |
| `DCP_DISABLE_PROCESS_CLEANUP_JOB` | On Windows, DCP will use a Win32 Job object to ensure that processes it launches are terminated when it shuts down. This alters standard process startup sequence and might not work on tightly locked-down machines, or might be flagged as "suspicious behavior" by antivirus software. If DCP cannot start processes and complains about "process cleanup job" errors, setting `DCP_DISABLE_PROCESS_CLEANUP_JOB` to `1` or `true` should help. |
