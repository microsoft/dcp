/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

package networking

import (
	"fmt"
	"net"
	"os"
	"path/filepath"
	"sync"

	"github.com/microsoft/dcp/internal/dcppaths"
	"github.com/microsoft/dcp/pkg/osutil"
	"github.com/microsoft/dcp/pkg/randdata"
)

// SecureSocketListener manages a Unix domain socket in a directory
// that enforces user-only access permissions. It handles secure directory creation,
// random socket name generation (to support multiple DCP instances without
// collisions), and socket file lifecycle management.
//
// SecureSocketListener implements net.Listener and can be used as a drop-in
// replacement anywhere a net.Listener is expected (e.g., gRPC server Serve()).
type SecureSocketListener struct {
	listener   net.Listener
	socketPath string

	closed bool
	mu     sync.Mutex
}

var _ net.Listener = (*SecureSocketListener)(nil)

// NewSecureSocketListener creates a new Unix domain socket listener in a secure,
// user-private directory. The socket file name is generated by combining the given
// prefix with a random suffix to avoid collisions between multiple DCP instances.
//
// If socketDir is empty, os.UserCacheDir() is used as the root directory. A "dcp-work"
// subdirectory is created (if it doesn't already exist) with owner-only permissions (0700).
// On Unix-like systems, the directory permissions are validated to ensure privacy.
//
// The socket file permissions are set to owner-only read/write (0600) on a best-effort
// basis — the chmod may not succeed on all platforms.
//
// The caller should call Close() when the listener is no longer needed. Close removes
// the socket file and closes the underlying listener.
func NewSecureSocketListener(socketDir string, socketNamePrefix string) (*SecureSocketListener, error) {
	secureDir, secureDirErr := PrepareSecureSocketDir(socketDir)
	if secureDirErr != nil {
		return nil, fmt.Errorf("failed to prepare secure socket directory: %w", secureDirErr)
	}

	suffix, suffixErr := randdata.MakeRandomString(8)
	if suffixErr != nil {
		return nil, fmt.Errorf("failed to generate random socket name suffix: %w", suffixErr)
	}

	socketPath := filepath.Join(secureDir, socketNamePrefix+string(suffix))

	// Remove any existing socket file (stale from a previous run)
	if _, statErr := os.Stat(socketPath); statErr == nil {
		if removeErr := os.Remove(socketPath); removeErr != nil {
			return nil, fmt.Errorf("failed to remove existing socket file %s: %w", socketPath, removeErr)
		}
	}

	listener, listenErr := net.Listen("unix", socketPath)
	if listenErr != nil {
		return nil, fmt.Errorf("failed to create Unix socket listener at %s: %w", socketPath, listenErr)
	}

	// Best-effort: set socket file permissions to owner-only.
	// This may not work on all platforms (e.g., Windows) but provides
	// defense-in-depth on systems that support it.
	_ = os.Chmod(socketPath, osutil.PermissionOnlyOwnerReadWrite)

	return &SecureSocketListener{
		listener:   listener,
		socketPath: socketPath,
	}, nil
}

// Accept waits for and returns the next connection to the listener.
// Returns net.ErrClosed if the listener has been closed.
func (l *SecureSocketListener) Accept() (net.Conn, error) {
	l.mu.Lock()
	if l.closed {
		l.mu.Unlock()
		return nil, net.ErrClosed
	}
	l.mu.Unlock()

	conn, acceptErr := l.listener.Accept()
	if acceptErr != nil {
		return nil, acceptErr
	}

	return conn, nil
}

// Close closes the listener and removes the socket file.
// Close is idempotent — subsequent calls return nil.
func (l *SecureSocketListener) Close() error {
	l.mu.Lock()
	defer l.mu.Unlock()

	if l.closed {
		return nil
	}

	l.closed = true

	closeErr := l.listener.Close()

	// Best effort removal of the socket file.
	_ = os.Remove(l.socketPath)

	return closeErr
}

// Addr returns the listener's network address.
func (l *SecureSocketListener) Addr() net.Addr {
	return l.listener.Addr()
}

// SocketPath returns the full path to the Unix socket file.
// The path includes the randomly generated suffix, so callers must use this
// method to discover the actual socket path after listener creation.
func (l *SecureSocketListener) SocketPath() string {
	return l.socketPath
}

// PrepareSecureSocketDir ensures a directory exists for creating Unix domain sockets
// that is writable only by the current user. The directory is created under rootDir
// with owner-only traverse permissions (0700).
//
// If rootDir is empty, os.UserCacheDir() is used as the root.
// On non-Windows systems, the directory permissions are validated after creation
// to ensure they have not been tampered with or set incorrectly.
//
// Returns the path to the secure directory.
func PrepareSecureSocketDir(rootDir string) (string, error) {
	if rootDir == "" {
		cacheDir, cacheDirErr := os.UserCacheDir()
		if cacheDirErr != nil {
			return "", fmt.Errorf("failed to get user cache directory for socket: %w", cacheDirErr)
		}
		rootDir = cacheDir
	}

	socketDir := filepath.Join(rootDir, dcppaths.DcpWorkDir)
	if mkdirErr := os.MkdirAll(socketDir, osutil.PermissionOnlyOwnerReadWriteTraverse); mkdirErr != nil {
		return "", fmt.Errorf("failed to create secure socket directory: %w", mkdirErr)
	}

	// On Windows the user cache directory always exists and is always private to the user,
	// but on Unix-like systems, we need to verify the directory is private.
	if !osutil.IsWindows() {
		info, infoErr := os.Stat(socketDir)
		if infoErr != nil {
			return "", fmt.Errorf("failed to check permissions on socket directory: %w", infoErr)
		}
		if !info.IsDir() {
			return "", fmt.Errorf("socket path %s is not a directory", socketDir)
		}
		if info.Mode().Perm() != osutil.PermissionOnlyOwnerReadWriteTraverse {
			return "", fmt.Errorf("socket directory %s is not private to the user (permissions: %o)", socketDir, info.Mode().Perm())
		}
	}

	return socketDir, nil
}
