parameters:
- name: signType
  displayName: 'Sign Type'
  values:
  - 'none'
  - 'test'
  - 'real'
  default: none
- name: testTimeout
  displayName: 'Test Timeout (seconds)'
  type: number
  default: 180
- name: windowsTestTimeout
  displayName: 'Windows Test Timeout (seconds)'
  type: number
  default: 240
- name: windowsPool
  displayName: 'Windows Pool'
  type: object
  default:
    name: AzurePipelines-EO
    image: 1ESPT-Windows2022
    os: windows
- name: linuxPool
  displayName: 'Linux Pool'
  type: object
  default:
    name: AzurePipelines-EO
    image: 1ESPT-Ubuntu20.04
    os: linux
- name: macPool
  type: object
  default:
    name: Azure Pipelines
    vmImage: macos-latest
    os: macOS

stages:
- stage: Build
  jobs:
  - job: Version
    displayName: 'Set Build Version'
    pool: ${{ parameters.linuxPool }}
    steps:
    - task: UseDotNet@2 # Install .NET 7.0 for GitVersion
      displayName: 'Install .NET 7.0'
      inputs:
        packageType: 'sdk'
        version: '7.0.x'

    - task: NuGetAuthenticate@1
      displayName: 'NuGet Authenticate'

    - task: bash@3 # Install GitVersion to calculate build versions
      displayName: 'Install GitVersion'
      inputs:
        script: dotnet tool install --global GitVersion.Tool --version "5.*"
        targetType: inline
        workingDirectory: '$(Build.SourcesDirectory)'

    - task: bash@3
      displayName: 'Initialize PR branch for GitVersion'
      condition: eq(variables['Build.Reason'], 'PullRequest')
      inputs:
        script: git checkout -b $(Build.SourceBranch)
        targetType: inline
        workingDirectory: '$(Build.SourcesDirectory)'

    - task: bash@3 # Run GitVersion and generate build variables
      displayName: 'GitVersion'
      inputs:
        script: dotnet-gitversion /output buildserver
        targetType: inline
        workingDirectory: '$(Build.SourcesDirectory)'

    - task: bash@3
      displayName: 'Export version variables'
      inputs:
        script: |
          echo "##vso[task.setvariable variable=buildTimestamp;isoutput=true]"$(date -u +%FT%TZ)
          echo "##vso[task.setvariable variable=semVer;isoutput=true]$(GitVersion.SemVer)"
          echo "##vso[task.setvariable variable=major;isoutput=true]$(GitVersion.Major)"
          echo "##vso[task.setvariable variable=minor;isoutput=true;isoutput=true]$(GitVersion.Minor)"
          echo "##vso[task.setvariable variable=patch;isoutput=true]$(GitVersion.Patch)"
          echo "##vso[task.setvariable variable=preReleaseTag;isoutput=true]$(GitVersion.PreReleaseTag)"
        targetType: inline
      name: version

  - job: Build
    dependsOn: Version
    variables:
      gitVersionSemVer: $[ dependencies.Version.outputs['version.semVer'] ]
      gitVersionMajor: $[ dependencies.Version.outputs['version.major'] ]
      gitVersionMinor: $[ dependencies.Version.outputs['version.minor'] ]
      gitVersionPatch: $[ dependencies.Version.outputs['version.patch']]
      buildTimestamp: $[ dependencies.Version.outputs['version.buildTimestamp'] ]
      GOPROXY: http://localhost:5000 # Use local proxy for Go modules
    templateContext:
      outputs:
      - output: pipelineArtifact
        path: $(Build.ArtifactStagingDirectory)/build
        artifact: drop
        artifactName: $(os)$(subos)_$(arch)_build
      - output: pipelineArtifact
        path: $(Build.ArtifactStagingDirectory)/build_archive
        artifact: drop
        artifactName: $(os)$(subos)_$(arch)_build_archive
      - output: pipelineArtifact
        path: $(Build.ArtifactStagingDirectory)/nuget
        artifact: drop
        artifactName: $(os)$(subos)_$(arch)_nuget

    strategy:
      matrix:
        windows-x86:
          os: windows
          arch: '386'
          subos: ''
          package: 'windows-386'
          extension: .exe
          build_cgo: 1
          build_cc: clang
          crypto: systemcrypto
          extras: 'clang'
        windows-amd64:
          os: windows
          arch: amd64
          subos: ''
          package: 'windows-amd64'
          extension: .exe
          build_cgo: 1
          build_cc: clang
          crypto: systemcrypto
          extras: 'clang'
        windows-arm64:
          os: windows
          arch: arm64
          subos: ''
          extension: .exe
          build_cgo: 1
          build_cc: clang
          crypto: systemcrypto
          extras: 'clang'
        linux-amd64:
          os: linux
          arch: amd64
          subos: ''
          extension: ''
          build_cgo: 1
          build_cc: ''
          crypto: systemcrypto
          extras: ''
        linux-arm64:
          os: linux
          arch: arm64
          subos: ''
          extension: ''
          build_cgo: 1
          build_cc: aarch64-linux-gnu-gcc
          crypto: systemcrypto
          extras: 'gcc-aarch64-linux-gnu'
        linux-musl-amd64:
          os: linux
          arch: amd64
          subos: -musl
          extension: ''
          build_cgo: 1
          build_cc: musl-gcc
          crypto: systemcrypto
          extras: 'musl-dev musl-tools'
        macos-amd64:
          os: darwin
          arch: amd64
          subos: ''
          extension: ''
          build_cgo: 0
          build_cc: ''
          crypto: ''
          extras: ''
        macos-arm64:
          os: darwin
          arch: arm64
          subos: ''
          extension: ''
          build_cgo: 0
          build_cc: ''
          crypto: ''
          extras: ''

    pool: ${{ parameters.linuxPool }}
    container: linux_build_container

    steps:
    - checkout: self
      persistCredentials: true

    - task: bash@3
      displayName: 'Install Sudo'
      target: host
      inputs:
        script: |
          docker exec -t -u root $(BuildContainerName) apt-get update
          docker exec -t -u root $(BuildContainerName) apt-get -o DPkg::Options::="--force-confold" install -y sudo
        targetType: inline

    - task: bash@3
      displayName: 'Prepare Dependencies'
      inputs:
        script: |
          echo "APT::Get::Assume-Yes \"true\";" | sudo tee -a /etc/apt/apt.conf.d/90assumeyes
          sudo apt-get install libicu-dev zip $(extras)
        targetType: inline

    - task: NuGetAuthenticate@1
      displayName: 'NuGet Authenticate'

    - task: UsePythonVersion@0
      displayName: 'Use Python 3.12'
      target: host
      inputs:
        versionSpec: '3.12'

    - task: bash@3
      displayName: 'Update Signing Dependencies'
      target: host
      inputs:
        script: |
          pip install --upgrade requests urllib3 cryptography pyopenssl
        targetType: inline

    - ${{ if and(ne(parameters.signType, 'none'), notin(variables['Build.Reason'], 'PullRequest')) }}:
      - task: MicroBuildSigningPlugin@4
        displayName: 'Install Signing Plugin'
        target: host # Signing runs on host to avoid having to install extra tools in the container
        inputs:
          signType: '${{ parameters.signType }}'
          azureSubscription: 'MicroBuild Signing Task (DevDiv)'
          feedSource: 'https://devdiv.pkgs.visualstudio.com/DefaultCollection/_packaging/MicroBuildToolset/nuget/v3/index.json'
        env:
            SYSTEM_ACCESSTOKEN: $(System.AccessToken)

    - task: UseDotNet@2 # Install .NET 3.1 for ddsign.dll
      displayName: 'Install .NET 3.1'
      target: host # Signing runs on host to avoid having to install extra tools in the container
      inputs:
        packageType: 'sdk'
        version: '3.1.x'

    - task: UseDotNet@2 # Install .NET 8.0 for NuGet publish
      displayName: 'Install .NET 8.0'
      inputs:
        packageType: 'sdk'
        version: '8.x'

    - task: UniversalPackages@0
      displayName: "Download credential provider Artifact"
      name: "download_credProvider"
      inputs:
        command: download
        vstsFeed: "DevDiv/usvc-apiserver"
        vstsFeedPackage: "terrapin-golang-cred-provider-linux-x64"
        vstsPackageVersion: "1.*"
        downloadDirectory: "$(Pipeline.Workspace)/terrapin-golang-cred-provider"

    - task: bash@3
      displayName: Start the golang credential provider
      inputs:
        targetType: inline
        script: |
          chmod +x $(Pipeline.Workspace)/terrapin-golang-cred-provider/terrapin-golang-cred-provider

          # Start the credential provider in the background
          $(Pipeline.Workspace)/terrapin-golang-cred-provider/terrapin-golang-cred-provider --start-background
      env:
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)

    - task: bash@3 # Ensure generated files are up to date
      displayName: 'Generate'
      inputs:
        script: make generate-ci
        targetType: inline
        workingDirectory: '$(Build.SourcesDirectory)'
      env:
        VERSION: '$(gitVersionSemVer)'
        VERSION_MAJOR: '$(gitVersionMajor)'
        VERSION_MINOR: '$(gitVersionMinor)'
        VERSION_PATCH: '$(gitVersionPatch)'
        BUILD_TIMESTAMP: '$(buildTimestamp)'

    - task: bash@3 # Build the DCP binaries
      displayName: 'Build'
      inputs:
        script: make release
        targetType: inline
        workingDirectory: '$(Build.SourcesDirectory)'
      env:
        GOOS: '$(os)'
        GOARCH: '$(arch)'
        CGO_ENABLED: '$(build_cgo)'
        CC: '$(build_cc)'
        GOEXPERIMENT: '$(crypto)'
        VERSION: '$(gitVersionSemVer)'
        VERSION_MAJOR: '$(gitVersionMajor)'
        VERSION_MINOR: '$(gitVersionMinor)'
        VERSION_PATCH: '$(gitVersionPatch)'
        BUILD_TIMESTAMP: '$(buildTimestamp)'

    - task: bash@3
      displayName: Print logs and stop background process
      condition: always()
      inputs:
        targetType: inline
        script: |
          # Print logs to console (may be spread across multiple files)
          Get-Content $HOME/.terrapin-golang-cred-provider/terrapin-golang-cred-provider.log*

          $(Pipeline.Workspace)/terrapin-golang-cred-provider/terrapin-golang-cred-provider --stop-background

    - task: bash@3 # Sign the windows binaries if necessary
      displayName: 'Sign Windows Binaries'
      condition: and(succeeded(), eq(variables.os, 'windows'), eq('${{ parameters.signType }}', 'real'))
      target: host # Signing runs on host to avoid having to install extra tools in the container
      inputs:
        script: dotnet $MBSIGN_APPFOLDER/DDSignFiles.dll -- /filelist:$BUILD_SOURCESDIRECTORY/.azure/pipelines/filelist-windows.xml
        targetType: inline
        workingDirectory: '$(Build.SourcesDirectory)'

    - task: bash@3 # Sign the MacOS binaries if necessary
      displayName: 'Sign MacOS Binaries'
      condition: and(succeeded(), eq(variables.os, 'darwin'), eq('${{ parameters.signType }}', 'real'))
      target: host # Signing runs on host to avoid having to install extra tools in the container
      inputs:
        script: |
          zip -ry $ARCHIVE_FILE ./bin/
          dotnet $MBSIGN_APPFOLDER/DDSignFiles.dll -- /file:$ARCHIVE_FILE /certs:8023
        targetType: inline
        workingDirectory: '$(Build.SourcesDirectory)'
      env:
        ARCHIVE_FILE: '$(Build.SourcesDirectory)/dcp-darwin.zip'

    - task: bash@3 # Notarize the MacOS binaries if necessary
      displayName: 'Notarize MacOS Binaries'
      condition: and(succeeded(), eq(variables.os, 'darwin'), eq('${{ parameters.signType }}', 'real'))
      target: host # Signing runs on host to avoid having to install extra tools in the container
      inputs:
        script: |
          dotnet $MBSIGN_APPFOLDER/DDSignFiles.dll -- /file:$ARCHIVE_FILE /certs:8020
          unzip -o $ARCHIVE_FILE
        targetType: inline
        workingDirectory: '$(Build.SourcesDirectory)'
      env:
        ARCHIVE_FILE: '$(Build.SourcesDirectory)/dcp-darwin.zip'

    - task: CopyFiles@2 # Copy the build output to the staging directory
      displayName: 'Copy Build Artifacts to Staging'
      inputs:
        Contents: '**'
        SourceFolder: '$(Build.SourcesDirectory)/bin/'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/build'

    - task: CopyFiles@2 # Copy the license file to staging
      displayName: 'Copy License Artifacts to Staging'
      inputs:
        Contents: |
          NOTICE
        SourceFolder: '$(Build.SourcesDirectory)'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/build'

    - task: ArchiveFiles@2
      displayName: 'Zip Windows Binaries'
      condition: and(succeeded(), eq(variables['os'], 'windows'))
      inputs:
        rootFolderOrFile: '$(Build.SourcesDirectory)/bin/'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/build_archive/$(os)$(subos)_$(arch)_$(gitVersionSemVer).zip'
        replaceExistingArchive: true

    - task: ArchiveFiles@2
      displayName: 'Tar/Gzip Unix Binaries'
      condition: and(succeeded(), ne(variables['os'], 'windows'))
      inputs:
        rootFolderOrFile: '$(Build.SourcesDirectory)/bin/'
        includeRootFolder: false
        archiveType: 'tar'
        archiveFile: '$(Build.ArtifactStagingDirectory)/build_archive/$(os)$(subos)_$(arch)_$(gitVersionSemVer).tar.gz'
        replaceExistingArchive: true

    - task: NuGetAuthenticate@1
      displayName: 'NuGet Authenticate'

    - task: DotNetCoreCLI@2 # Build the NuGet package for Arcade
      displayName: 'Package NuGet'
      inputs:
        command: 'build'
        projects: '$(Build.SourcesDirectory)/.azure/DcpNuGet/DcpNuGet.csproj'
        arguments: -p:TargetPlatform=$(os)$(subos)-$(arch) -p:BuildDir=$(Build.SourcesDirectory)/bin/ -p:Version=$(gitVersionSemVer)

    - task: CopyFiles@2 # Copy the nuget files to staging
      displayName: 'Copy NuGet Artifacts to Staging'
      inputs:
        Contents: '*.nupkg'
        SourceFolder: '$(Build.SourcesDirectory)/package/'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/nuget'

    - task: MicroBuildCleanup@1
      condition: succeededOrFailed()

  - job: MergeArtifacts
    displayName: 'Merge NuGet Artifacts'
    dependsOn: Build
    templateContext:
      type: artifactJob
      inputs:
      - input: pipelineArtifact
        artifactName: windows_386_nuget
        targetPath: $(Build.ArtifactStagingDirectory)/nuget/
      - input: pipelineArtifact
        artifactName: windows_amd64_nuget
        targetPath: $(Build.ArtifactStagingDirectory)/nuget/
      - input: pipelineArtifact
        artifactName: windows_arm64_nuget
        targetPath: $(Build.ArtifactStagingDirectory)/nuget/
      - input: pipelineArtifact
        artifactName: linux_amd64_nuget
        targetPath: $(Build.ArtifactStagingDirectory)/nuget/
      - input: pipelineArtifact
        artifactName: linux_arm64_nuget
        targetPath: $(Build.ArtifactStagingDirectory)/nuget/
      - input: pipelineArtifact
        artifactName: linux-musl_amd64_nuget
        targetPath: $(Build.ArtifactStagingDirectory)/nuget/
      - input: pipelineArtifact
        artifactName: darwin_amd64_nuget
        targetPath: $(Build.ArtifactStagingDirectory)/nuget/
      - input: pipelineArtifact
        artifactName: darwin_arm64_nuget
        targetPath: $(Build.ArtifactStagingDirectory)/nuget/
      - input: pipelineArtifact
        artifactName: windows_386_build_archive
        targetPath: $(Build.ArtifactStagingDirectory)/build_archive/
      - input: pipelineArtifact
        artifactName: windows_amd64_build_archive
        targetPath: $(Build.ArtifactStagingDirectory)/build_archive/
      - input: pipelineArtifact
        artifactName: windows_arm64_build_archive
        targetPath: $(Build.ArtifactStagingDirectory)/build_archive/
      - input: pipelineArtifact
        artifactName: linux_amd64_build_archive
        targetPath: $(Build.ArtifactStagingDirectory)/build_archive/
      - input: pipelineArtifact
        artifactName: linux_arm64_build_archive
        targetPath: $(Build.ArtifactStagingDirectory)/build_archive/
      - input: pipelineArtifact
        artifactName: linux-musl_amd64_build_archive
        targetPath: $(Build.ArtifactStagingDirectory)/build_archive/
      - input: pipelineArtifact
        artifactName: darwin_amd64_build_archive
        targetPath: $(Build.ArtifactStagingDirectory)/build_archive/
      - input: pipelineArtifact
        artifactName: darwin_arm64_build_archive
        targetPath: $(Build.ArtifactStagingDirectory)/build_archive/
      outputs:
      - output: pipelineArtifact
        targetPath: $(Build.ArtifactStagingDirectory)/nuget/
        artifactName: nuget
      - output: pipelineArtifact
        targetPath: $(Build.ArtifactStagingDirectory)/build_archive/
        artifactName: build_archive

- stage: Test
  dependsOn: []
  jobs:
  - job: TestLinux
    displayName: 'Test Linux'
    pool: ${{ parameters.linuxPool }}
    variables:
      GOPROXY: http://localhost:5000 # Use local proxy for Go modules
    steps:
    - template: install-microsoft-go.yml
      parameters:
        version: '$(MicrosoftGoVersion)'
        os: linux
        arch: amd64

    - task: UniversalPackages@0
      displayName: "Download credential provider Artifact"
      name: "download_credProvider"
      inputs:
        command: download
        vstsFeed: "DevDiv/usvc-apiserver"
        vstsFeedPackage: "terrapin-golang-cred-provider-linux-x64"
        vstsPackageVersion: "1.*"
        downloadDirectory: "$(Pipeline.Workspace)/terrapin-golang-cred-provider"

    - pwsh: |
        chmod +x $(Pipeline.Workspace)/terrapin-golang-cred-provider/terrapin-golang-cred-provider

        # Start the credential provider in the background
        $(Pipeline.Workspace)/terrapin-golang-cred-provider/terrapin-golang-cred-provider --start-background
      displayName: Start the golang credential provider
      env:
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)

    - task: bash@3
      displayName: 'Test'
      inputs:
        script: make test-ci
        targetType: inline
        workingDirectory: '$(Build.SourcesDirectory)'
      env:
        CGO_ENABLED: 1
        GOEXPERIMENT: systemcrypto
        PATH: '$(Agent.TempDirectory)/go/bin:$(PATH)'
        GOROOT: '$(Agent.TempDirectory)/go'
        TEST_CONTEXT_TIMEOUT: ${{ parameters.testTimeout }} # Increase test timeout to deal with slow tests
        DCP_DIAGNOSTICS_LOG_LEVEL: debug
        DCP_DIAGNOSTICS_LOG_FOLDER: $(Build.ArtifactStagingDirectory)/test-logs

    - pwsh: |
        # Print logs to console (may be spread across multiple files)
        Get-Content $HOME/.terrapin-golang-cred-provider/terrapin-golang-cred-provider.log*

        $(Pipeline.Workspace)/terrapin-golang-cred-provider/terrapin-golang-cred-provider --stop-background
      condition: always()
      displayName: Print logs and stop background process

    - task: 1ES.PublishPipelineArtifact@1
      displayName: 'Publish Test Logs'
      condition: or(failed(), eq(variables['Agent.Diagnostic'], 'true'))
      inputs:
        targetPath: $(Build.ArtifactStagingDirectory)/test-logs
        artifactName: linux_test_logs

  - job: TestWindows
    displayName: 'Test Windows'
    pool: ${{ parameters.windowsPool }}
    variables:
      GOPROXY: http://localhost:5000 # Use local proxy for Go modules
    steps:
    - template: install-microsoft-go.yml
      parameters:
        version: '$(MicrosoftGoVersion)'
        os: windows
        arch: amd64
        extension: '.zip'

    - task: ChocolateyToolInstaller@1

    - task: PowerShell@2
      displayName: 'Choco Install'
      inputs:
        script: choco install make mingw -y
        targetType: inline

    - task: UniversalPackages@0
      displayName: "Download credential provider Artifact"
      name: "download_credProvider"
      inputs:
        command: download
        vstsFeed: "DevDiv/usvc-apiserver"
        vstsFeedPackage: "terrapin-golang-cred-provider-win-x64"
        vstsPackageVersion: "1.*"
        downloadDirectory: "$(Pipeline.Workspace)/terrapin-golang-cred-provider"

    - pwsh: |
        # Start the credential provider in the background
        $(Pipeline.Workspace)/terrapin-golang-cred-provider/terrapin-golang-cred-provider --start-background
      displayName: Start the golang credential provider
      env:
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)

    - task: PowerShell@2
      displayName: 'Test'
      inputs:
        script: make test-ci
        targetType: inline
        workingDirectory: '$(Build.SourcesDirectory)'
      env:
        CGO_ENABLED: 1
        GOEXPERIMENT: systemcrypto
        PATH: '$(Agent.TempDirectory)\go\bin;$(PATH)'
        GOROOT: '$(Agent.TempDirectory)\go'
        TEST_CONTEXT_TIMEOUT: ${{ parameters.windowsTestTimeout }} # Increase test timeout to deal with slow tests
        DCP_DIAGNOSTICS_LOG_LEVEL: debug
        DCP_DIAGNOSTICS_LOG_FOLDER: $(Build.ArtifactStagingDirectory)\test-logs

    - pwsh: |
        # Print logs to console (may be spread across multiple files)
        Get-Content $HOME/.terrapin-golang-cred-provider/terrapin-golang-cred-provider.log*

        $(Pipeline.Workspace)/terrapin-golang-cred-provider/terrapin-golang-cred-provider --stop-background
      condition: always()
      displayName: Print logs and stop background process

    - task: 1ES.PublishPipelineArtifact@1
      displayName: 'Publish Test Logs'
      condition: or(failed(), eq(variables['Agent.Diagnostic'], 'true'))
      inputs:
        targetPath: $(Build.ArtifactStagingDirectory)\test-logs
        artifactName: windows_test_logs

  - job: TestMacOS
    displayName: 'Test MacOS'
    pool: ${{ parameters.macPool }}
    # Disabled until we can get credential provider working with the MacOS pool
    # variables:
      # GOPROXY: http://localhost:5000 # Use local proxy for Go modules
    steps:
    - task: GoTool@0 # No darwin build of Microsoft Go, so use the standard build
      displayName: 'Install Go'
      inputs:
        version: '$(GoVersion)'

    - task: UniversalPackages@0
      displayName: "Download credential provider Artifact"
      name: "download_credProvider"
      enabled: false # disabled until we can get credential provider working with the MacOS pool
      inputs:
        command: download
        vstsFeed: "DevDiv/usvc-apiserver"
        vstsFeedPackage: "terrapin-golang-cred-provider-osx-x64"
        vstsPackageVersion: "1.*"
        downloadDirectory: "$(Pipeline.Workspace)/terrapin-golang-cred-provider"

    - pwsh: |
        chmod +x $(Pipeline.Workspace)/terrapin-golang-cred-provider/terrapin-golang-cred-provider

        # Start the credential provider in the background
        $(Pipeline.Workspace)/terrapin-golang-cred-provider/terrapin-golang-cred-provider --start-background
      displayName: Start the golang credential provider
      enabled: false # disabled until we can get credential provider working with the MacOS pool
      env:
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)

    - task: PowerShell@2
      displayName: 'Test'
      inputs:
        script: make test-ci
        targetType: inline
        workingDirectory: '$(Build.SourcesDirectory)'
      env:
        TEST_CONTEXT_TIMEOUT: ${{ parameters.testTimeout }} # Increase test timeout to deal with slow tests
        DCP_DIAGNOSTICS_LOG_LEVEL: debug
        DCP_DIAGNOSTICS_LOG_FOLDER: $(Build.ArtifactStagingDirectory)/test-logs

    - pwsh: |
        # Print logs to console (may be spread across multiple files)
        Get-Content $HOME/.terrapin-golang-cred-provider/terrapin-golang-cred-provider.log*

        $(Pipeline.Workspace)/terrapin-golang-cred-provider/terrapin-golang-cred-provider --stop-background
      condition: always()
      enabled: false # disabled until we can get credential provider working with the MacOS pool
      displayName: Print logs and stop background process

    - task: 1ES.PublishPipelineArtifact@1
      displayName: 'Publish Test Logs'
      condition: or(failed(), eq(variables['Agent.Diagnostic'], 'true'))
      inputs:
        targetPath: $(Build.ArtifactStagingDirectory)/test-logs
        artifactName: darwin_test_logs

- stage: Arcade
  condition: and(succeeded(), notin(variables['Build.Reason'], 'PullRequest'), eq(variables.shouldDeploy, 'true'))
  dependsOn:
  - Build
  - Test
  - SDLSources
  jobs:
  - job: NuGetPublish
    displayName: 'Publish NuGet'
    templateContext:
      inputs:
      - input: pipelineArtifact
        artifactName: nuget
        targetPath: $(Pipeline.Workspace)/nuget
    steps:
    - task: NuGetAuthenticate@1
      displayName: 'NuGet Authenticate'

    - task: 1ES.PublishNuget@1
      displayName: Publish Nuget packages
      inputs:
        packagesToPush: '$(Pipeline.Workspace)/nuget/**/*.nupkg'
        packageParentPath: '$(Pipeline.Workspace)/nuget/'
        publishVstsFeed: '$(deployFeed)'  # Required when pushing to internal feed.
        nuGetFeedType: internal  # Change to external when publishing to external feed
        allowPackageConflicts: true # Allows skipping package versions that already exist in the feed (otherwise this would be an error)

    - task: PowerShell@2
      displayName: 'Tag Build'
      inputs:
        script: |
          Write-Host "##vso[build.addbuildtag]$(environment)"
        targetType: inline

  - job: ArcadeManifestBuild
    displayName: 'Build Arcade Manifest'
    pool: ${{ parameters.windowsPool }}
    dependsOn:
    - NuGetPublish
    variables:
    - group: Publish-Build-Assets
    - name: gitVersionPreReleaseTag
      value: $[ stageDependencies.Build.Version.outputs['version.preReleaseTag'] ]
    templateContext:
      inputs:
      - input: pipelineArtifact
        artifactName: nuget
        targetPath: $(Pipeline.Workspace)/nuget
    steps:
    - task: UseDotNet@2
      displayName: 'Install .NET 9.0'
      inputs:
        packageType: 'sdk'
        version: '9.0.x'

    - task: NuGetAuthenticate@1
      displayName: 'NuGet Authenticate'

    - task: PowerShell@2
      displayName: 'Set Release Variable'
      condition: and(succeeded(), eq(variables['gitVersionPreReleaseTag'], ''))
      inputs:
        script: Write-Host "##vso[task.setvariable variable=IsReleaseOnlyPackageVersion]true"
        targetType: inline

    - task: DotNetCoreCLI@2
      displayName: 'Build Arcade Manifest'
      inputs:
        command: 'build'
        projects: '$(Build.SourcesDirectory)/.azure/ArcadeManifest/ArcadeManifest.csproj'
        arguments: -t:GenerateAssetManifest -restore -p:NuGetClientNupkgsDirectoryPath=$(Pipeline.Workspace)/nuget/ -p:NuGetFeed=$(feedName) -p:ArtifactsLogDir=$(Build.ArtifactStagingDirectory)/arcade/ -p:MaestroApiEndpoint=$(MaestroApiEndpoint)

  - job: ArcadeManifestPublish
    displayName: 'Publish Arcade Manifest'
    pool: ${{ parameters.windowsPool }}
    dependsOn:
    - ArcadeManifestBuild
    variables:
    - group: Publish-Build-Assets
    templateContext:
      inputs:
      - input: pipelineArtifact
        artifactName: nuget
        targetPath: $(Pipeline.Workspace)/nuget
    steps:
    - download: current
      artifact: AssetManifests
      displayName: 'Download Arcade Manifest Artifact'

    - task: UseDotNet@2
      displayName: 'Install .NET 9.0'
      inputs:
        packageType: 'sdk'
        version: '9.0.x'

    - task: NuGetAuthenticate@1
      displayName: 'NuGet Authenticate'

    - task: AzureCLI@2
      displayName: 'Publish Manifest to Arcade'
      inputs:
        azureSubscription: "Darc: Maestro Production"
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          dotnet build $(Build.SourcesDirectory)/.azure/ArcadeManifest/ArcadeManifest.csproj -t:PublishAssetManifest -p:Version=$(Build.BuildNumber) -p:ManifestsPath=$(Pipeline.Workspace)/AssetManifests -p:MaestroApiEndpoint=$(MaestroApiEndpoint)

    - task: PowerShell@2
      name: BARSVariables
      displayName: Set BARS Variable
      inputs:
        script: |
          Write-Host "##vso[task.setvariable variable=barBuildId;isOutput=true]$env:BAR_BUILD_ID"
          Write-Host "BuildId: $env:BAR_BUILD_ID"
        targetType: inline
      env:
        BAR_BUILD_ID: $(BARBuildId)

  - job: ArcadeBuildPromote
    displayName: 'Promote to Arcade Channel'
    pool: ${{ parameters.windowsPool }}
    dependsOn:
    - ArcadeManifestPublish
    variables:
    - group: Publish-Build-Assets
    - name: barBuildId
      value: $[ dependencies.ArcadeManifestPublish.outputs['BARSVariables.barBuildId'] ]
    - name: gitVersionPreReleaseTag
      value: $[ stageDependencies.Build.Version.outputs['version.preReleaseTag'] ]
    steps:
    - task: UseDotNet@2
      displayName: 'Install .NET 9.0'
      inputs:
        packageType: 'sdk'
        version: '9.0.x'

    - task: PowerShell@2
      displayName: Set Channel to '$(InternalDarcChannel)'
      condition: and(succeeded(), or(ne(variables['gitVersionPreReleaseTag'], ''), ne(variables['Build.Reason'], 'Manual'))) # CI builds only go to the internal channel
      inputs:
        script: Write-Host "##vso[task.setvariable variable=darcChannel]$(InternalDarcChannel)"
        targetType: inline

    - task: PowerShell@2
      displayName: Set Channel to '$(PublicDarcChannel)'
      condition: and(succeeded(), and(eq(variables['gitVersionPreReleaseTag'], ''), eq(variables['Build.Reason'], 'Manual'))) # Only manual builds can go to the public channel
      inputs:
        script: Write-Host "##vso[task.setvariable variable=darcChannel]$(PublicDarcChannel)"
        targetType: inline

    - task: PowerShell@2
      displayName: Install Darc
      inputs:
        script: |
          $darcCliPackageName = 'microsoft.dotnet.darc'
          $versionEndpoint = 'https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16'
          $darcVersion = $(Invoke-WebRequest -Uri $versionEndpoint -UseBasicParsing).Content
          $arcadeServicesSource = 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
          Write-Host "Installing Darc CLI version $darcVersion..."
          Write-Host "dotnet tool install $darcCliPackageName --version $darcVersion --add-source '$arcadeServicesSource' -g"
          dotnet tool install $darcCliPackageName --version $darcVersion --add-source "$arcadeServicesSource" -g
        targetType: inline

    - task: AzureCLI@2
      displayName: 'Publish Manifest to Arcade'
      inputs:
        azureSubscription: "Darc: Maestro Production"
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          Write-Host "darc add-build-to-channel --ci --id "$(barBuildId)" --publishing-infra-version 3 --channel "$(darcChannel)" --source-branch main --bar-uri $(MaestroApiEndpoint)"
          darc add-build-to-channel --ci --id "$(barBuildId)" --publishing-infra-version 3 --channel "$(darcChannel)" --source-branch main --bar-uri $(MaestroApiEndpoint) --azdev-pat $(System.AccessToken)
